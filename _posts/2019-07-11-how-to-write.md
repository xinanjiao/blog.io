---
layout: post
title: 搬椅子
date: 2019-7-11
categories: blog
tags: [算法,贪心，模拟]
description: 语言
---
### 题目描述
上课的时候总会有一些同学和前后左右的人交头接耳，这是令小学班主任十分头疼的一件事情。不过，班主任小雪发现了一些有趣的现象，当同学们的座次确定下来之后，只有有限的D对同学上课时会交头接耳。

同学们在教室中坐成了M行N列，坐在第i行第j列的同学的位置是(i,j)(i,j)，为了方便同学们进出，在教室中设置了K条横向的通道，L条纵向的通道。

于是，聪明的小雪想到了一个办法，或许可以减少上课时学生交头接耳的问题：她打算重新摆放桌椅，改变同学们桌椅间通道的位置，因为如果一条通道隔开了2个会交头接耳的同学，那么他们就不会交头接耳了。

请你帮忙给小雪编写一个程序，给出最好的通道划分方案。在该方案下，上课时交头接耳的学生的对数最少。

### 输入输出格式
输入格式：<br/>
第一行，有5个用空格隔开的整数，分别是M,N,K,L,D(2 <= N,M <= 1000,0 <= K<M,0 <= L < N,D <= 2000)M,N,K,L,D(2≤N,M≤1000,0≤K<M,0≤L<N,D≤2000)<br/>
接下来的D行，每行有4个用空格隔开的整数。第i行的4个整数a,b,c,d,表示在（a,b），（c,d)两个坐标会交头接耳，（输入保证他们前后相邻或者左右相邻）。<br/>
输入数据保证最优方案的唯一性。<br/>
   

输出格式:<br/>
共两行：<br/>
第一行包含K个整数a1,a2,a3,....,ak，表示a1-a2之间，a2-a3之间,....,ak,到ak+1行需要开辟通道，每两个整数之间用空格隔开（行尾没有空格）。<br/>
​第二行:<br/>
第二行包含L个整数b1,b2,b3,....,bL，表示b1-b2之间，b2-b3之间,....,bL,到bL+1列需要开辟通道，每两个整数之间用空格隔开（行尾没有空格）。<br/>
### 输入输出样例
输入：<br/>
4 5 1 2 3<br/>
4 2 4 3<br/>
2 3 3 3<br/>
2 5 2 4<br/>
输出:<br/>
2<br/>
2 4<br/>
### 说明
![说明](/img/20.png)
上图中用符号星号、※、+标出了33对会交头接耳的学生的位置，图中33条粗线的位置表示通道，图示的通道划分方案是唯一的最佳方案。<br/>

#### 冷静分析
.....刚开始实际上没办法冷静，没有一个好思路和好办法。实际上这种题已经不是第一次了，在我看来，这种题我把它归纳为抽象题。通俗地说就是，你人看起来很容易的事情，你要翻译给计算机理解。我遇到的其他题比如：给你很多点，找到一个竖线当对称轴（紫书上）。铺地毯，铺很多层，计算覆盖某点最上面层的地毯编号（洛谷）等等。这些题实际上不用真的找，反正就是用计算机的方法归纳就行。这道题做完后现在看来，好像也是我说的那回事，只不过这道题有点新的地方就是简单的用到了**贪心**。
##### 贪心
贪婪算法(Greedy algorithm)是一种对某些求最优解问题的更简单、更迅速的设计技术。用贪婪法设计算法的特点是一步一步地进行，常以当前情况为基础根据某个优化测度作最优选择，而不考虑各种可能的整体情况，它省去了为找最优解要穷尽所有可能而必须耗费的大量时间，它采用自顶向下，以迭代的方法做出相继的贪心选择，每做一次贪心选择就将所求问题简化为一个规模更小的子问题，通过每一步贪心选择，可得到问题的一个最优解，虽然每一步上都要保证能获得局部最优解，但由此产生的全局解有时不一定是最优的，所以贪婪法不要回溯。
贪婪算法是一种改进了的分级处理方法。其核心是根据题意选取一种量度标准。然后将这多个输入排成这种量度标准所要求的顺序，按这种顺序一次输入一个量。如果这个输入和当前已构成在这种量度意义下的部分最佳解加在一起不能产生一个可行解，则不把此输入加到这部分解中。这种能够得到某种量度意义下最优解的分级处理方法称为贪婪算法。
对于一个给定的问题，往往可能有好几种量度标准。初看起来，这些量度标准似乎都是可取的，但实际上，用其中的大多数量度标准作贪婪处理所得到该量度意义下的最优解并不是问题的最优解，而是次优解。因此，选择能产生问题最优解的最优量度标准是使用贪婪算法的核心。

一般情况下，要选出最优量度标准并不是一件容易的事，但对某问题能选择出最优量度标准后，用贪婪算法求解则特别有效。最优解可以通过一系列局部最优的选择即贪婪选择来达到，根据当前状态做出在当前看来是最好的选择，即局部最优解选择，然后再去解做出这个选择后产生的相应的子问题。每做一次贪婪选择就将所求问题简化为一个规模更小的子问题，最终可得到问题的一个整体最优解。
                        -------《360百科》<br/>
 有点高深叭，我来简单理解一下，反正这道题也是很简单的用到了贪心，我也是第一次接触贪心。<br/>
 贪心算法是什么意思？举个例子就很清楚了：现在你有一个能装4斤苹果的袋子，苹果有两种，一种3斤一个，一种2斤一个，怎么装才能得到最多苹果？当然我们人考虑的话当然是拿两个2斤的苹果，就刚好装满了，但是如果按贪心算法拿的话，首先就要把最重的苹果拿下（是不是很符合贪心两个字？），但并没有得到最多苹果。

贪心算法保证了局部最优，但并不能保证得到最优解。

<p style="color: red;">反正就拿选最多或最优的就行了（以后在慢慢补充我的理解）</p>

#### 继续分析
先想一下算法：因为题目里出现了“最优解”，“最好的方案”关键字，所以一定会用贪心。然后从题目给的样例解释可以看到：如果相邻的两行有许多组说话的同学，那么在这两行中间加一条过道是非常划算的；同理，列也是如此。
恍然大悟，只要找出划分哪些相邻的两行和相邻的两列可以隔开的同学最多，此题可解。
<p style="color: red;">这里排序和结构体可以学习到</p>

### 代码
    #include<bits/stdc++.h>
    using namespace std;
    const int maxn=1000+10;
    typedef struct node
    {
     int sum,l;
    } node;
    bool cmp(const node a,const node b)
    {
    return a.sum>b.sum;
    }
    bool cmp2(const node a,const node b)
    {
    return a.l<b.l;
    }
    int main()
    {
    node a[maxn];//行
    node b[maxn];//列
    memset(a,0,sizeof(node));
    memset(b,0,sizeof(node));
    int m,n,k,l,d;
    cin>>m>>n>>k>>l>>d;
    for(int i=0;i<m;i++)
    {
        a[i].l=i;
    }
    for(int i=0;i<n;i++)
    {
        b[i].l=i;
    }
    for(int i=0;i<d;i++)
    {
        int a1,b1,c,f;
        cin>>a1>>b1>>c>>f;
        if(a1!=c)//为同列
        a[min(a1,c)].sum++;
            else
            {
                b[min(b1,f)].sum++;
            }
    }
    sort(a,a+m,cmp);
    sort(a,a+k,cmp2);
    sort(b,b+n,cmp);
    sort(b,b+l,cmp2);
    for(int i=0;i<k;i++)
    {
        if(i==0)
            cout<<a[i].l;
        else
           cout<<" "<<a[i].l;
    }
    cout<<endl;
    for(int i=0;i<l;i++)
    {
        if(i==0)
            cout<<b[i].l;
        else
           cout<<" "<<b[i].l;
    }
    }