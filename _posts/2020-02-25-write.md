---
layout: post
title: POJ专题之深度搜索
date: 2020-02-25
categories: blog
tags: [深度搜索]
description: 文章金句。
---

### 搜索
今天延长版假期的第17天，但我的功课好像落下了....在家没有教材确实看不太进去。但看这开学的时间遥遥无期，就必须强制自己好好规划了！

疫情得到了很好的控制，谢谢前线的工作人员，你们是真正的英雄！！！

搜索以前还是没有领悟到精髓啊，现在回头看，还是有些懵，但多做几道后就有了更深刻的理解。

keep on!

### A Knight's Journey POJ - 2488 打印路径且字典序最小
#### 题目大意
 
整天待在一个方块里, 骑士感到特别的无聊, 于是, 他决定来一场所走就走的旅行 
但他只能走日字, 并且世界是一个不大于8 x 8的棋盘.你能帮勇敢的骑士制定一个旅行计划吗? 
请找出一条路使得骑士能够走遍整个棋盘.骑士可以在任一方块出发或结束 

第一行输入一个正整数n, 代表数据组数 
对于每组数据, 含有两个正整数p和q(1 <= p x q <= 26), 表示一个p x q的棋盘.每个方块的位置用两个字符表示, 第一个从A开始,代表列, 第二个从1开始,代表行

每组数据的结果首先是一行"Scenario i:", i是数据序号, 从1开始 
然后输出一行, 是字典序第一的可以走遍棋盘的路径, 接着有一个空行 
路径应该是连续的依次所走方块的位置 
如果不存在这样的路径, 输出"impossible"

#### 思路
暴力dfs即可，淡要注意的是：行列相乘为26，而不是p和q都最大是26，所以也不会出现8 * 8的棋盘。<br>

路径打印参照以前的dfs打印模板一敲就行了，注意因为如果能全部覆盖，那从A1开始必然字典序最小，而且方向的变换还很关键，走日字型，我就是因为这个方向问题wa了很多次。

```
const int maxn = 20190324+10;
const int hashmaxn=8388608;
int lowbit(int x){return x&(-x);}
int dir[8][2]={{-1,-2},{1,-2},{-2,-1},{2,-1},{-2,1},{2,1},{-1,2},{1,2}};
int n,m,sum;
bool book[30][30];
vector<string> v;
bool dfs(int a,int b,int cnt){
        if(cnt==sum)
            return true;
    for(int i=0;i<8;i++){
        int x=a+dir[i][0];
        int y=b+dir[i][1];
        if(x<=0||x>n||y<=0||y>m||book[x][y])
            continue;
            //cout<<x<<" ?_? "<<y<<endl;
        book[x][y]=1;
        if(dfs(x,y,cnt+1)){
            string s="";
           //cout<<x<<" "<<y<<endl;
            s.push_back(y-1+'A');
            s.push_back(x+'0');
            v.push_back(s);
            return true;
        }
        book[x][y]=0;
    }
    return false;
}
int main()
{
    ios::sync_with_stdio(0);
    int t,ans=1;
    cin>>t;
    while(t--){
        cin>>n>>m;
        cout<<"Scenario "<<ans++<<":"<<endl;
        sum=n*m;
        bool flag=0;
        mem(book,0);
        v.clear();
        if(n==1&&m==1){
            cout<<"A1"<<endl<<endl;
            continue;
        }
        if(sum>26||n>=9||m>=9||n<=2||m<=2){
                cout<<"impossible"<<endl;
        cout<<endl;
        continue;
        }

        book[1][1]=1;
        if(dfs(1,1,1)){
           string s="A1";
           v.push_back(s);
            flag=1;
            }
        if(flag){
         for(int i=v.size()-1;i>=0;i--)
                cout<<v[i];
         cout<<endl;
        }
        else
            cout<<"impossible"<<endl;
        cout<<endl;
    }
    return 0;
}
```


### Dungeon Master POJ - 2251 高维BFS

#### 题目大意
XHK被困在一个三维的网吧中,现在要寻找最短路径逃生！
空间由立方体单位构成
你每次向上下前后左右移动一个单位需要一分钟
你不能对角线移动并且四周封闭
是否存在逃出生天的可能性？如果存在，则需要多少时间？

输入第一行是一个数表示空间的数量。
每个空间的描述的第一行为L，R和C（皆不超过30）。
L表示空间的高度。
R和C分别表示每层空间的行与列的大小。
随后L层地牢，每层R行，每行C个字符。
每个字符表示空间的一个单元。'&'表示不可通过单元，'.'表示空白单元。你的起始位置在'S'，出口为'E'。
每层空间后都有一个空行。L，R和C均为0时输入结束

#### 思路
以后大数据最短路都用BFS吧！！

这是三维的图，原来做过，但放弃了....现在再次遇见熟悉了不少。

三维就多了一个维度，和两个方向（前后左右，上下）。一样的bfs。注意维度的控制

```
char mp[50][50][50];
bool book[50][50][50];
int dirtion[6][3]={{1,0,0},{0,1,0},{-1,0,0},{0,-1,0},{0,0,1},{0,0,-1}};
int sx,sy,sl;
int flag=0;
int t,n,m;
struct node{
    int x,y,l,step;
    node(){}
    node(int a,int b,int c,int d):x(a),y(b),l(c),step(d){}
};
bool bfs(){
    queue<node> p;
    p.push(node(sx,sy,sl,0));
    book[sx][sy][sl]=1;
    while(!p.empty()){
        node a=p.front();
        p.pop();
        if(mp[a.x][a.y][a.l]=='E'){
                flag=a.step;
            return true;
        }
        for(int i=0;i<6;i++){
            int x=a.x+dirtion[i][0];
            int y=a.y+dirtion[i][1];
            int l=a.l+dirtion[i][2];
            if(x>=n||x<0||y<0||y>=m||l<0||l>=t||book[x][y][l]||mp[x][y][l]=='&')
                continue;
                book[x][y][l]=1;
              p.push(node(x,y,l,a.step+1));
        }
    }
    return false;
}
int main()
{
    ios::sync_with_stdio(0);
    while(cin>>t>>n>>m&&t){
            flag=0;
        mem(book,0);
        fro(i,0,t){
            fro(j,0,n){
              fro(k,0,m){
                cin>>mp[j][k][i];
                if(mp[j][k][i]=='S'){sx=j;sy=k;sl=i;}
              }
            }
            getchar();
        }
        if(bfs())
            cout<<"Escaped in "<<flag<<" minute(s)."<<endl;
        else

            cout<<"Trapped!"<<endl;
    }
    return 0;
}
```
