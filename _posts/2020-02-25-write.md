---
layout: post
title: POJ专题之深度搜索
date: 2020-02-25
categories: blog
tags: [深度搜索]
description: 文章金句。
---

### 搜索
今天延长版假期的第17天，但我的功课好像落下了....在家没有教材确实看不太进去。但看这开学的时间遥遥无期，就必须强制自己好好规划了！

疫情得到了很好的控制，谢谢前线的工作人员，你们是真正的英雄！！！

搜索以前还是没有领悟到精髓啊，现在回头看，还是有些懵，但多做几道后就有了更深刻的理解。

keep on!

### A Knight's Journey POJ - 2488 打印路径且字典序最小
#### 题目大意
 
整天待在一个方块里, 骑士感到特别的无聊, 于是, 他决定来一场所走就走的旅行 
但他只能走日字, 并且世界是一个不大于8 x 8的棋盘.你能帮勇敢的骑士制定一个旅行计划吗? 
请找出一条路使得骑士能够走遍整个棋盘.骑士可以在任一方块出发或结束 

第一行输入一个正整数n, 代表数据组数 
对于每组数据, 含有两个正整数p和q(1 <= p x q <= 26), 表示一个p x q的棋盘.每个方块的位置用两个字符表示, 第一个从A开始,代表列, 第二个从1开始,代表行

每组数据的结果首先是一行"Scenario i:", i是数据序号, 从1开始 
然后输出一行, 是字典序第一的可以走遍棋盘的路径, 接着有一个空行 
路径应该是连续的依次所走方块的位置 
如果不存在这样的路径, 输出"impossible"

#### 思路
暴力dfs即可，淡要注意的是：行列相乘为26，而不是p和q都最大是26，所以也不会出现8 * 8的棋盘。<br>

路径打印参照以前的dfs打印模板一敲就行了，注意因为如果能全部覆盖，那从A1开始必然字典序最小，而且方向的变换还很关键，走日字型，我就是因为这个方向问题wa了很多次。

```
const int maxn = 20190324+10;
const int hashmaxn=8388608;
int lowbit(int x){return x&(-x);}
int dir[8][2]={{-1,-2},{1,-2},{-2,-1},{2,-1},{-2,1},{2,1},{-1,2},{1,2}};
int n,m,sum;
bool book[30][30];
vector<string> v;
bool dfs(int a,int b,int cnt){
        if(cnt==sum)
            return true;
    for(int i=0;i<8;i++){
        int x=a+dir[i][0];
        int y=b+dir[i][1];
        if(x<=0||x>n||y<=0||y>m||book[x][y])
            continue;
            //cout<<x<<" ?_? "<<y<<endl;
        book[x][y]=1;
        if(dfs(x,y,cnt+1)){
            string s="";
           //cout<<x<<" "<<y<<endl;
            s.push_back(y-1+'A');
            s.push_back(x+'0');
            v.push_back(s);
            return true;
        }
        book[x][y]=0;
    }
    return false;
}
int main()
{
    ios::sync_with_stdio(0);
    int t,ans=1;
    cin>>t;
    while(t--){
        cin>>n>>m;
        cout<<"Scenario "<<ans++<<":"<<endl;
        sum=n*m;
        bool flag=0;
        mem(book,0);
        v.clear();
        if(n==1&&m==1){
            cout<<"A1"<<endl<<endl;
            continue;
        }
        if(sum>26||n>=9||m>=9||n<=2||m<=2){
                cout<<"impossible"<<endl;
        cout<<endl;
        continue;
        }

        book[1][1]=1;
        if(dfs(1,1,1)){
           string s="A1";
           v.push_back(s);
            flag=1;
            }
        if(flag){
         for(int i=v.size()-1;i>=0;i--)
                cout<<v[i];
         cout<<endl;
        }
        else
            cout<<"impossible"<<endl;
        cout<<endl;
    }
    return 0;
}
```


