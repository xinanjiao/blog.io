---
layout: post
title: POJ专题之简单搜索技巧和剪枝
date: 2020-02-28
categories: blog
tags: [搜索]
description: 文章金句。
---

### DFS+剪枝
对于很多数据小的题，完全可以DFS深搜解决。DFS深搜也是一种暴力枚举的思路，但也有很多技巧。在暴力枚举的基础上加上剪枝（去掉不符合的状态），就可以让效率高很多。剪枝也是一门学问。边学边总结叭！

### Network Saboteur POJ - 2531 DFS
#### 题目大意
给出一个N * N的矩阵，位置为D(i,j)，表示第i个点到第j个点的边权为D。能否将这些点分为互不相交的两个集合A,B。使A到B的点的所有边权之和最大。

#### 思路
刚开始被两个集合的互不相交给整懵逼了。实际上题目给出的是一个完全图。听说也就是图论里面的网络流最大割。网络流还没有接触，但这道题的数据很小，完全可以把所有可能枚举出来来比较。<br>

枚举的技巧很巧妙。就是刚开始把全部放入A集合，然后一个个枚举放入B集合，算出边权之和。最后输出即可。剪枝之处就是当转移比原来小，就不用转移了。转移完后，就把标记清除。

```
int mp[30][30];
bool book[30];
int maxa=0;
int n;
void dfs(int a,int b){
    book[a]=1;
    int d=b;
    fro(i,1,n+1){
        if(!book[i])
            d+=mp[a][i];
        else
            d-=mp[a][i];
    }
    maxa=max(maxa,d);
    fro(i,a+1,n+1){
        if(d>b){
        dfs(i,d);
        book[i]=0;
        }
    }
}
int main()
{
    ios::sync_with_stdio(0);

    cin>>n;
    fro(i,1,n+1)
     fro(j,1,n+1)
      cin>>mp[i][j];
    dfs(1,0);
    cout<<maxa<<endl;
    return 0;
}
```












