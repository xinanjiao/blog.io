---
layout: post
title: POJ专题之广度搜索（续）
date: 2020-02-27
categories: blog
tags: [广度搜索]
description: 语言
---

### BFS
做了这几道题，发现对原来紫书提到的‘状态’一词，理解真的好大，最后解题都可以归结到状态里面来，然而BFS也是处理状态一个高效的办法，找到每次的状态变化，然后剪枝就行了。

### Shuffle'm Up POJ - 3087  模拟
#### 题目大意
洗牌。输入两个字符串s1,s2，先s2第一张牌放在上面，然后s1的第一张牌放在上面，最后直到都没有了，形成另外一个串s12。最后看是否与输入待匹配的串是否一样，如果不一样就一分为二，前面为s1，后面为s2。重复操作！不能转换输出-1，能就输出次数

#### 思路
就模拟操作，怎么知道不能装换呢，就是有重复出现的状态就标记退出，那就输出-1。

```
const int maxn = 1e4+10;
const int hashmaxn=8388608;
int lowbit(int x){return x&(-x);}
int main()
{
    ios::sync_with_stdio(0);
    int t,case1=1;
    cin>>t;
    while(t--){
        int len;
        cin>>len;
        string s1,s2,s12="",ans;
        cin>>s1>>s2>>ans;
        map<string,int> mp;
        int cnt=0;
        cout<<case1++<<" ";
        bool ok=0;
        while(1){
            for(int i=0;i<len;i++){
                s12.push_back(s2[i]);
                s12.push_back(s1[i]);
            }
            cnt++;
            if(s12==ans){
                ok=1;
                break;
            }
            if(mp[s12])
                break;
            mp[s12]=1;
            s1=s12.substr(0,len);
            s2=s12.substr(len,len);
            s12.clear();
        }
        if(ok)
            cout<<cnt<<endl;
        else
            cout<<-1<<endl;
    }
    return 0;
}
```












