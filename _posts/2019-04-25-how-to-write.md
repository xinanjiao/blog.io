---
layout: post
title: 浅对DFS深度优先搜索的理解
date: 2019-4-25
categories: blog
tags: [算法,深度搜索]
description: 语言
---
ps.这是小菜鸡的我对dfs的理解，如果有差错，请各位斧正，不胜感激！<br/>

理解深度优先搜索的关键在于解决**当下该如何做**。至于“下一步如何做”则与“当下该如何做”是一样的。比如我们这里写的dfs(step)函数的主要功能就是解决当你在第step个盒子的时候该怎么办。通常的方法就是把每一种可能都去尝试一遍（一般使用for循环来遍历）。当前这一步解决后便进入下一步dfs(step+1).<br/>
dfs模板

    void dfs(int step)
    {
    判断边界
    尝试每一种可能for(i=1;i<=n;i++)
    {
        继续下一步dfs(step+1);
        //这里有非常重要的一步（回溯）
    }
    返回；

《啊哈，算法》上有一道全排列的题，其中就用到了DFS。就它为例，谈谈我的理解。<br/>

输入一个数n，输出它的全排列。<br/>
如：3<br/>
123，132，213，231，321，312.<br/>

建立n个盒子，把1——n的数枚举出来，先从第一个盒子开始放，放到最后一个盒子，判断边界条件，发现没有牌了（撞南墙了），往回走（回头），拿出最后一个盒子的牌，不行啊，只有一张牌，所以再往前拿一张牌，交换两个牌。。。。。照这样执行下去，得到全排列。当然，要在判断完边界条件就输出全排列。代码实现：<br/>

    #include<bits/stdc++.h>
    using namespace std;//book[]数组是一个标记数组，为了标记哪些数值用过，哪些没有。
    int box[10],book[10],n;//当数组定义在全局变量中时，没有赋值之前，默认为零
    void dfs(int step)//step这里代表第几个盒子
    {
    int i;
    if(step==n+1)//边界条件，代表前n个盒子都装好了，就输出
    {
        for(i=1;i<=n;i++)
            cout<<box[i]<<" ";
        cout<<endl;
        return;//这步很关键，下面我会提及
    }
    for(i=1;i<=n;i++)
    {
        if(book[i]==0)
        {
            box[step]=i;//装盒子操作
            book[i]=1;//装过的数字标记为1，代表用过
            dfs(step+1);//递归调用自身，体现了只管当前操作，后面的步骤就当已经做好了
            book[i]=0;//记得把放好的牌拿出来喔，不然不能交换操作（回溯）
        }
    }
    return ;//结束
    }
    int main()
    {
    cin>>n;
    dfs(1);
    }

最近才了解这个算法，想了很久，主要是在if（）里面的return ;和dfs(step+!)中思考了很久。<br/>
我们先看dfs(step+1),看代码部分，我们以n=3为例。<br/>
运行到这个部分<br/>

    for(i=1;i<=n;i++)
    {
        if(book[i]==0)
        {
            box[step]=i;
            book[i]=1;
            dfs(step+1);
            book[i]=0;
        }
    }

box[1]=1，第一个盒子放1;<br/>
book[1]标记为1,代表1已经用了。<br/>
运行到dfs(step+1)部分，调用自身，dfs(2),这里可以看为<br/>

    for(i=1;i<=n;i++)
    {
        if(book[i]==0)
        {
            box[step]=i;
            book[i]=1;
           {//dfs{step+1)调用自身
            int i;
    if(step==n+1)
    {
        for(i=1;i<=n;i++)
            cout<<box[i]<<" ";
        cout<<endl;
        return;
    }
    for(i=1;i<=n;i++)
    {
        if(book[i]==0)
        {
            box[step]=i;
            book[i]=1;
            dfs(step+1);
            book[i]=0;
        }
    }
    return ;
    }//dfs(step+1)
            book[i]=0;
        }
    }


这里dfs调用了自身，我们可以看出在上面代码中又要调用一次自身，这次是dfs(3),在dfs(2)中有了dfs(3)，这时step+1==4触发边界条件，输出一个全排列。可能有人就疑惑了，后面这么回溯呢？这是就要看if()中的return；它的作用是返回到最近的一次dfs调用，最近的是哪次？对！dfs(3)，注意到dfs(3)中的循环了吗，因为数1，2，都被标记，所以它已经循环到三了，结束循环，执行调用语句下面一句，释放3的标记，dfs(3)的循环结束了，别忘了它在dfs(2)中的，所以在dfs(2)中重复dfs(3)的操作。。。。这样一直到dfs(1)，最主要的循环加一，第一个盒子的数从1变为2，重复以上操作，直到全部排列输出…<br/>

笔芯啦啦啦~~~~~
