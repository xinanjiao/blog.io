---
layout: post
title: Function
date: 2019-4-21
categories: blog
tags: [算法,记忆化搜索]
description: 算法学习
---
### 题目描述


>对于一个递归函数w(a,b,c)<br/>  
>如果  a≤0 or  b≤0 or 0  c≤0 就返回值 1.<br/> 
>如果a>20 or b>20 or c>20就返回w(20,20,20)...<br/>  
>如果a<b并且b<c 就返回w(a,b,c−1)+w(a,b−1,c−1)−w(a,b−1,c)...<br/>  
>其它的情况就返回w(a−1,b,c)+w(a−1,b−1,c)+w(a−1,b,c−1)−w(a−1,b−1,c−1)...<br/>  
>这是个简单的递归函数，但实现起来可能会有些问题。当a,b,c均为15时，调用的次数将非常的多。你要想个办法才行.

###### 特别的
比如 w(30,-1,0)既满足条件1又满足条件2
这种时候我们就按最上面的条件来算  所以答案为1

#### 输入输出格式

#### 输入格式
  若干行
  并以-1 -1 -1 结束
  保证输入的数在[-9223372036854775808,9223372036854775807]之间，并且是整数。

#### 输出格式
  输出若干行
  如
  >w(a, b, c)=ans;
  >>注意空格

#### 输入输出样例        
>输入样例              
>> 1 1 1              
>> 2 2 2              
>> -1 -1 -1


>输出样例<br/>
w(1, 1, 1)=2<br/>
w(2, 2, 2)=4 

代码部分：


    #include <bits/stdc++.h>
    using namespace std;
    long long int p[25][25][25];//开辟数组储存每次计算的值
    long long int wabc(long long int a,long long int b,long long int c)

    {
    if(a<=0||b<=0||c<=0)
    {
        return 1;
    }

    else if(p[a][b][c]!=0)//如果遇到这个值计算过，直接返回
    {
        return p[a][b][c];
    }
    else if(a>20||b>20||c>20)
    {
         p[a][b][c]=wabc(20,20,20);
    }

    else if(a<b&&b<c)
    {
         p[a][b][c]=wabc(a,b,c-1)+wabc(a,b-1,c-1)-wabc(a,b-1,c);
    }
    else
       p[a][b][c]=wabc(a-1,b,c)+wabc(a-1,b-1,c)+wabc(a-1,b,c-1)-wabc(a-1,b-1,c-1);
       return p[a][b][c];
    }
    int main()
    {
    long long int a,b,c;
    memset(p,0,sizeof(long long int));
    while(1)
    {
        cin>>a>>b>>c;
        if(a==-1&&b==-1&&c==-1)
            break;
        cout<<"w("<<a<<", "<<b<<", "<<c<<") = ";
        if(a>20) a=21;
        if(b>20) b=21;
        if(c>20) c=21;
        cout<<wabc(a,b,c)<<endl;
    }
    }


## 个人~~弟弟~~想法
 *记忆化搜索，就是在每次反复的递归中，把重复的部分省去计算，进而达到减少运算量，减少复杂度的目的*<br/>
 这道题呢，三维数组着实吓我一跳，可能我没有反应过来吧，~~我太菜了~~，行了，既然如此，那就是长知识了，这个三维数组记录了每次运算的值，如果有重复的直接返回，那就没有多余的运算了，实际上这个几维数组的确定主要是你传进来的参数~~个人猜想~~这种搜索方法呢主要用于递归。
>记忆化搜索的思想
>>记忆化搜索的思想是,在搜索过程中，会有很多重复计算,如果我们能记录一些状态的答案，就可以减少重复搜索量

>记忆化搜索的适用范围
>>根据记忆化搜索的思想，它是解决重复计算，而不是重复生成，也就是说，这些搜索必须是在搜索扩展路径的过程中分步计算的题目，也就是“搜索答案与路径相关”的题目，而不能是搜索一个路径之后才能进行计算的题目，必须要分步计算，并且搜索过程中，一个搜索结果必须可以建立在同类型问题的结果上，也就是类似于动态规划解决的那种<br/>
>>也就是说，他的问题表达，不是单纯生成一个走步方案，而是生成一个走步方案的代价等，而且每走一步，在搜索树/图中生成一个新状态，都可以精确计算出到此为止的费用，也就是，可以分步计算，这样才可以套用已经得到的答案<br/>

>记忆化搜索的核心实现
>>a. 首先，要通过一个表记录已经存储下的搜索结果，一般用哈希表实现<br/>
>>b.状态表示，由于是要用哈希表实现，所以状态最好可以用数字表示，常用的方法是把一个状态连写成一个p进制数字，然后把这个数字对应的十进制数字作为状态<br/>
>>c.在每一状态搜索的开始，高效的使用哈希表搜索这个状态是否出现过，如果已经做过，直接调用答案，回溯<br/>
>>d.如果没有，则按正常方法搜索<br/>

*记忆化搜索是类似于动态规划的，不同的是，它是倒做的“递归式动态规划*




