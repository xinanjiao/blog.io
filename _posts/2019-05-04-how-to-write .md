---
layout: post
title: 约瑟夫环
date: 2019-05-04
categories: blog
tags: [算法]
description: 语言
---
**问题由来**
在罗马人占领乔塔帕特后，39 个犹太人与Josephus及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，由第1个人开始报数，每报数到第3人该人就必须自杀，然后再由下一个重新报数，直到所有人都自杀身亡为止。然而Josephus 和他的朋友并不想遵从。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。问题是，给定了和，一开始要站在什么地方才能避免被处决？Josephus要他的朋友先假装遵从，他将朋友与自己安排在第16个与第31个位置，于是逃过了这场死亡游戏。
  其中josephus就是约瑟夫，军事家，政治家，数学家。

最近做题老是遇到约瑟夫，这小老头好像和我过不去了一样，那也行吧，迟早要遇到（实际上上学期就遇到了《猴子选大王》），上学期也试着去理解它，但在智商无情的被螺旋鞭挞几个回合后放弃了，今天必须将你了结。<br/>
<br/>
为此，我查阅在网上了很多大牛的博客，有很多做法，有用**链表**来模拟的，还有用**队列**来模拟的，但代码很复杂，我也不太理解。可喜的是，还有从数学方面理解的，代码很短，虽然不好理解，但是多想想也就好了。

### 从数学方面来理解约瑟夫环

我就不从头开始推导了，参见博客[传送门](https://blog.csdn.net/u011500062/article/details/72855826)<br/>

此题用的是递推的思想。分析不同人数时的幸存者，把他们列为一排，返回幸存者下标。

设函数f(n,m)结果为最后幸存者的序号，n为总人数，m为数的步数。<br/>
举个栗子：当n=11,m=3时。<br/>
1. f(1,3)时，幸存者就是它自己，为0。
2. f(2,3)时，有两个人，f(2,3)=(f(1,3)+m)%2=1。有两个人时，返回幸存者下标1。
3. f(3,3)时，有三个人，f(3,3)=(f(2,3)+m)%3=1。有三个人时返回下标1。
   .....
11. f(11,3)时，11个人，f(11,3)=(f(10,3)+m)%11=6。最终幸存者在原来数组中下标为6。

写为代码为：

    int cir(int n,int m)
    {
       int p=0;
    for(int i=2;i<=n;i++)
    {
        p=(p+m)%i;
    }
        return p+1;
    }

<p style="color: red;font-size: 18px;">这样有个局限，就是因为他是数学方法，所以它忽略了过程,如果就叫你输出最后的胜利者，用这个方法很好。</p>



比如uva440<br/>

### Description
你一定有过这样的经历：当太多人同时使用互联网时，网络会变得非常非常缓慢。

为解决这一问题，乌尔姆大学制定了一个高峰负荷时段的应急方案，以系统、完全公平的方式切断全国部分城市的网络接入。德国的城市是从1到N随机列举的，弗赖堡是1，乌尔姆(ulm)是2，卡尔斯鲁厄是3，等等，都是纯随机的。

然后随机选取一个数字m，首先在城市1（显然是最公平的起点）切断互联网接入，然后在每一个MTH城市，从n到1，忽略已经切断的城市。例如，如果n=17，m=5，则按顺序切断城市的净接入[1,6,11,16,5,12,2,9,17,10,4,15,14,3,8,13,7]。问题是，最公平的做法是最后切断ULM（毕竟，这是最好的程序员的来源），因此对于给定的n，需要仔细选择随机数m，以便城市2是最后选择的城市。



你的工作是编写一个程序，它将在多个城市n中读取，然后确定最小整数m，以确保ulm可以在全国其他地区被切断的情况下上网。

### input

输入将包含一行或多行，每行包含一个整数n，3<=n<150，代表该国的城市数量。

对于n，输入以零（0）的值终止。

### output

对于输入的每一行，打印一行包含整数m，满足上面指定的要求。

### Sample Input
3
4
5
6
7
8
9
10
11
12
0

### Sample Output

2
5
2
4
3
11
2
3
8
16

code:

     #include <bits/stdc++.h>
     using namespace std;
     int main()
    {
       int n,step,i,j;
      while(cin>>n&&n!=0)
      {
        for(i=1;;i++)//i为我们要寻找的步数
        {
            step=0;
            for(j=2;j<n;j++)//j!=n
                step=(step+i)%j;
            if(step==0)
            {
                cout<<i<<endl;
                break;
            }
        }
       }
    }

  这道题是告诉你最后剩下的，叫你求最小的步数，是反运用，你只需要暴力求解即可，把最后位置固定，从1开始匹配步数，满足时跳出。<br/>

<p style="color: red;font-size: 18px;">上述说了有过程未知的局限，现在我们看看下一种针对过程而且很好理解的方法。</p>

### Description
 N个人围成一圈顺序编号，从1号开始按1、2、3......顺序报数，报p者退出圈外，其余的人再从1、2、3开始报数，报p的人再退出圈外，以此类推。 请按退出顺序输出每个退出人的原序号。

### input
输入只有一行，包括一个整数N(1<=N<=3000)及一个整数p(1<=p<=5000)。

### output

按退出顺序输出每个退出人的原序号，数据间以一个空格分隔，但行尾无空格。

### sampel input
7<br/>
3

### sampel output

3 6 2 7 5 1 4<br/>

具体分析看代码叭.

    #include <bits/stdc++.h>
    using namespace std;
    int main()
    {
    int n,m;//输入步数，总人数
    cin>>n>>m;
    int book[n];//计数桶
    for(int i=0;i<n;i++)
        book[i]=0;//全部初始化为0
    int sum=0,renshu=n;
    for(int i=0;;i=(i+1)%n)
     {
        if(book[i]==0)sum++;//为0表示为出列
        if(book[i]==1)continue;
        if(sum==m)//与步数相等，表示到了那个人
        {
            cout<<i+1<<" ";//输出
            book[i]=1;//出列
            sum=0;//重新开计数
            renshu--;//人数-1
        }
        if(renshu==0)break;
      }
    }

很好理解而且实用！<br/>

一道拔高题<br/>
uva133,[题目链接](https://vjudge.net/problem/UVA-133)。<br/>

    include <bits/stdc++.h>
    using namespace std;
    int n,k,m,a[21];
    int go(int p,int d,int t)//d=1顺时针，d=-1,逆时针
    {
    while(t--)
    {
        do
        {
            p=(p+d+n-1)%n+1;//核心
        }while(a[p]==0);//读过的变为零，跳过
    }
    return p;
    }
    int main()
    {
    while(cin>>n>>k>>m&&n!=0&&k!=0&&m!=0)
    {
       for(int i=1;i<=n;i++)a[i]=i;
       int left=n;
       int p1=n;//a法官顺时针
       int p2=1;//b法官逆时针
       while(left)
       {
       p1=go(p1,1,k);
       p2=go(p2,-1,m);
       cout<<setw(3)<<p1;
       left--;
       if(p1!=p2)
       {
           cout<<setw(3)<<p2;
           left--;
       }
       a[p1]=a[p2]=0;
       if(left!=0)
        cout<<",";
       }
       cout<<endl;
    }
    }