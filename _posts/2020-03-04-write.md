---
layout: post
title: POJ专题之动态规划背包（续）
date: 2020-03-04
categories: blog
tags: [动态规划]
description: 文章金句。
---

### 完全背包 多重背包
这两个背包都基于01背包。<br>
完全背包物品可以无限拿，多重背包物品有数量限制。<br>
多重背包=（完全背包）+01背包<br>
多重背包转换为上面的形式时是复杂度最优的。<br>

今天虽然是一道多重背包板子题，我也觉得好难（哭）。暑假还了解过，现在忘得一干二净了，原来暑假只是背的板子（哭），根本没有理解嗷嗷嗷！！！

### Cash Machine POJ - 1276 多重背包
#### 题目大意
给出一个数P，表示待换取的金额数目。之后给出n个数，有N对数字，第一个为该金额钞票的数目，第二个为钞票金额。<br>

问用N个钞票尽可能换P的金额。

#### 思路
背包问题挺明显的，而且数目还有限制，那就是多重背包了。<br>

很多背包问题为了降低复杂度都是转化为01背包的。所以多重转化为01背包的一个思路为：**将每个物品按个数展开，看为一个物品，那就可以像01背包一样拿或者不拿**<br>

这个复杂度是不可观的，就这道题而言，如果按数目展开，复杂度就为1e9所以铁定超时。所以引出**神奇的二进制优化**<br>

<p style="color: red">二进制优化</p>

刚看到这个名称，以为是状态压缩还是其他的，压缩为二进制表示状态。但细看并不是，它只是借鉴了二进制的思想。
<div style="color: red">
<p>简单来说，就是把一个数字分成   （1  2  4  8.........最大数） 这样下去的类型</p>

<p>为什么呢？ 因为这些数字可以组成（1~ 最大数）中的任何一个数</p>

<p>这也就意味着，我们可以实现组合</p>

<p>其实思路还是和上面的一样，还是把这些抽出来变成一个新的产品，不过  重量和价值   有所不同。</p>
</div>

有点迷糊，真的不是很理解，好像是一个结论叭，emmmm记住它！！！

下面是它的一个流程板子，就是和上面思路差不多，只不过不是一个个的分解，而是二进制的分解，还是一个思路滴。

<p style="color: red">如果这样还超时的话，考虑完全背包加01背包优化，也就是当数量乘以价值大于给出的值的时候就用完全背包（因为可以无限拿呀）。反之就01背包，记住一维数组的区别就是for循环顺序不同！！！</p>

```
for (int i = 1; i <= spe; i++)
        {
            //核心代码
            for (int j = 1; num[i] > j; j <<= 1)//注意j用到二进制位移
            {
                sale[++count] = sale[i] * j;
                wei[count] = wei[i] * j;
                num[i] -= j;
            }
            wei[i] = wei[i] * num[i];
            sale[i] = sale[i] * num[i];
        }
```

注意num[i]要减去j，最后还要将剩下的num[i]利用


```
int dp[maxn];
int num[1100];
int value[1100];
int main()
{
    ios::sync_with_stdio(0);
    int n;
    while(cin>>n){
        mem(dp,0);mem(value,0);mem(num,0);
        int cnt=0;
        int m;
        cin>>m;
        fro(i,1,m+1){//二进制优化
        int a,b;
        cin>>a>>b;
        for(int j=1;j<=a;j*=2){
            value[++cnt]=j*b;
            a-=j;
          }
          if(a!=0)
            value[++cnt]=a*b;
        }
        //fro(i,1,cnt+1)
         //   cout<<value[i]<<" ";
        for(int i=1;i<=cnt;i++){
            for(int j=n;j>=0;j--){
                if(j>=value[i])
                    dp[j]=max(dp[j],dp[j-value[i]]+value[i]);
            }
        }
        cout<<dp[n]<<endl;
    }
    return 0;
}
```







