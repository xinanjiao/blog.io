---
layout: post
title: 动态规划之矩阵链乘
date: 2020-02-27
categories: blog
tags: [动态规划]
description: 文章金句。
---

### 矩阵链乘
一个m行n列的矩阵与一个n行p列的矩阵相乘，会得到一个m行p列的矩阵，具体步骤如下：

<p style="color: red">其中第i行第j列位置上的数为第一个矩阵的第i行上的n个数与第二个矩阵第j列上的n个数对应相乘后所得的n个乘积之和。</p>

假设我们要用标准的矩阵乘法计算M1、M2、M3的乘积M1M2M3，这三个矩阵的维数分别是2x10，10x2，2x10。

如果我们先把M1M1和M2M2相乘，然后把结果和M3M3相乘，即（（M1M2）M3）。那么要进行2x10x2+2x2x10=80次乘法；
如果我们先乘M2M3，结果再与M1相乘，即（M1（M2M3））。那么数量乘法的次数就变成了：10x2x10+2x10x10=400。
可见，矩阵链相乘时的顺序不同，运算量也不同。而我们的目的是找到一种乘法顺序使得运算量最小。

这就是问题由来

### 应用动态规划的方法的步骤
1. 刻画一个最优解的结构特征

2. 递归地定义最优解的值

3. 计算最优解的值，通常采用自底向上的方法

4. 利用计算出的信息构造一个最优解的值


### 第一步：刻画一个最优解的结构特征

对于最开始提出的问题，我们看作为矩阵链乘设计最优的括号化方案。而设置括号的最终目的就是为了打乱计算顺序，通过结合律来找到最小计算代价，就比如下面一个问题33*4*25，是个正常人就会先计算后面两项，因为这样好计算，同样计算矩阵，我们也希望计算的少，计算的快啊，设置括号就变的尤为重要了。

对于完全括号化，每一个括号的作用是将一个链乘转化成两个完全括号化的链乘的积，前面有提到。

因此我最优解的结构特征就如下了：

对于第m个矩阵到第n个矩阵，他的最优解存在于对它的一次划分中，它的划分有n-m种情况，我们对这些情况中代价取最小，不就获得了最优解

而对于每种情况，我们需要划分后的两部分矩阵链都是最优解，乘积后才可能最小啊，（这部分大家可以用“剪切--粘贴”去反证），这样问题就转换成了两个子部分矩阵链的最优括号化方案的问题，以此不断的递归下去。


### 第二步：递归地定义最优解的值
我们的划分点k可从m到n-1，代价如下所示，每次的代价如下，而最优解只有一个，即它们的最小值：

其一般化的公式如下：
![02272](/img/02272.png)

从这里可以看出，这是一个递归的问题，看着很类似上篇所述的钢条切割问题啊，仔细比对比对吧。

若采用递归策略，可能会有很多的重复子问题，无疑提高了计算的复杂度。也可以采取带备忘的递归来降低复杂度。


### 第三步：计算最优解的值，通常采用自底向上的方法
另外从公式中可以看出，上述计算结果要依赖于m,n（m< n）的所有可能组合。区间[m，n]组合要依赖于它们之间的子区间组合。所以我们采取自下而上的策略，逐渐扩大m,n之间的区间长度，最终算到m=0,n=n，从而获得最优的括号化方案，


### 第四步、利用计算出的信息构造一个最优解的值
我们可以做出如下的二维表格。
![0227](/img/0227.jpg)

解释一下：m[i,j]就等于计算A(i..k)和A(k+1..j)的代价加上两者相乘的代价的最小值。
余下的对角线根据上面的递推式和先前存储在表中值来填。举例来说，C[2][5]的值为以下三个耗费的最小值： <br>
– (1)计算M2,2的耗费（即C[2][2])加上计算M3,5（即C[3][5]）的耗费，再加上M2,2乘以M3,5的耗费。 <br>
– (2)计算M2,3的耗费（即C[2][3])加上计算M4,5（即C[4][5]）的耗费，再加上M2,3乘以M4,5的耗费。 <br>
– (3)计算M2,4的耗费（即C[2][4])加上计算M5,5（即C[5][5]）的耗费，再加上M2,4乘以M5,5的耗费。<br>


参考博客:<https://blog.csdn.net/Neo_kh/article/details/81282025><https://www.cnblogs.com/qinghua0310/p/4078656.html><https://blog.csdn.net/c18219227162/article/details/50412333?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task>

### 矩阵链乘法 NBUT - 1003 模板题
#### 题目大意
上同

#### 分析
如上

模板
```
const int maxn = 1e4+10;
const int hashmaxn=8388608;
int lowbit(int x){return x&(-x);}
//矩阵链乘
int a[300];
int dp[300][300];
int main()
{
    ios::sync_with_stdio(0);
    int n;
    while(cin>>n){
        mem(a,0);mem(dp,INF);
        fro(i,0,n+1)
        cin>>a[i];
        fro(i,1,n+1){
            dp[i][i]=0;
        }
        for(int len=2;len<=n;len++){
            for(int i=1,j=len;j<=n;i++,j++){
                for(int k=i;k<j;k++)
                    dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+a[i-1]*a[j]*a[k]);
            }
        }
        cout<<dp[1][n]<<endl;
    }
    return 0;
}
```