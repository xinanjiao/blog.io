---
layout: post
title: POJ专题之广度搜索
date: 2020-02-26
categories: blog
tags: [广度搜索]
description: 文章金句。
---

### 广度搜索
广度搜索复杂度没有dfs高，是求最优路径的一个好选择。多数时候求最短路径还是广度搜索叭<br>
关于打印路径问题，可以边加入队列边记录位置，也可用数组记录它下一个位置。<br>

### Find The Multiple POJ - 1426 BFS+有问题
#### 题目大意
输入一个n，(1<=n<=200)。求输出一个由01组成的串，满足该串能被n整除，不能为0。

#### 思路
可以暴力BFS，有两个状态后面为1或者为0，加进队列，但考虑该串可以为200的长度，可能队列将会很长，但这道题用long long 的长度就可以找到答案，不需要大数的处理，那就暴力即可。<br>

思路很明确，但一直有个小bug，我在BFS里面输出那个答案就对了，返回主函数输出就错了....后面再BFS里面最后加了返回语句也能A，我和队友一致认为该题有问题（(｡･∀･)ﾉﾞ嗨）

```
int n;
void bfs(){
    queue<ll> p;
    p.push(1);
    while(!p.empty()){
        ll a=p.front();p.pop();
        if(a%n==0){
            cout<<a<<endl;
            break;
        }

        p.push(a*10);
        p.push(a*10+1);
    }
}
int main()
{
    ios::sync_with_stdio(0);
    while(cin>>n&&n){
        bfs();
    }
    return 0;
}
```












