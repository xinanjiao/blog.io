---
layout: post
title: 威佐夫博弈（Wythoff Game）
date: 2019-9-17
categories: blog
tags: [算法,博弈]
description: 语言
---
### 威佐夫博弈
有2堆石子。A B两个人轮流拿，A先拿。每次可以从一堆中取任意个或从2堆中取相同数量的石子，但不可不取。拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出2堆石子的数量，问最后谁能赢得比赛。

用（a, b）来表示两堆石头的剩余情况，如果某个人遇到了这样的状态(0,0)那么也就是说这个人输了。这样的状态我们叫做奇异状态,也可以叫做失败态。
从第0个失败态开始(0,0),(1,2),(3,5),(4,7),(6,10),(8,13)。

### 有以下规律
第i个失败态的两个数的差值为i。

用a[i]表示失败态中的第一个数,b[i]表示失败态中的第二个数.(i从0开始)。那么a[i]是前面的失败态中没有出现过的最小的整数，b[i] = a[i]+i;（i >= 0）。

1.每个数仅包含在一个失败态中。
2.每个失败态可以转到非失败态。
3.每个非失败态都可以转到一个失败态。

每个失败态中两个数的差值 * 1.618的向下取整就是这个失败态的第一个数。
给两堆石子，求先手输赢，就可以根据这组数是不是失败态来判断先手是否会赢
如果还要求假设先手赢，先手第一次怎么取石子，可以分为同时取和在一堆取，主要是取后的石子为失败态。

### 结论

结论：若两堆物品的初始值为（x，y），并且x< y，则令z=y-x；

记temp=（int）[（（sqrt（5.0）+1.0）/2.0）* z  ]；

若temp=x，则先手败，否则先手胜。

### 取石子游戏 HDU - 1527 
题目链接：<https://vjudge.net/problem/HDU-1527><br/>
题目大意：<br/>
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。 <br/>
思路：威佐夫博弈模板题。

    const int maxn=2e5+10;
    const int INF=0x3f3f3f3f;
    int main()
    {
    ios::sync_with_stdio(false);
    ll a,b;
    while(cin>>a>>b)
    {
        if(a>b)
            swap(a,b);
       ll temp=floor((b-a)*((1.0+sqrt(5.0))/2.0));
       if(temp==a)
        cout<<0<<endl;
       else
        cout<<1<<endl;
    }
    return 0;
    }

### 取石子游戏升级版 hdu-2177
题目链接:<https://vjudge.net/problem/HDU-2177><br/>
题目大意：<br/>
有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。如果你胜，你第1次怎样取子? <br/>
思路：<br/>
分析和上一题一样，很容易就判断出来谁胜谁负，但有个很大的不同就是要求输出第一次怎么取子，而且要求如果可以同时取子且获胜，现输出同时取石子的操作。temp为最终标准，如果能必胜，以temp1为标准同时减去(a-temp);另外种情况就是模拟了，具体见下代码

    const int INF=0x3f3f3f3f;
    const int maxn = 1e4+10;
    int lowbit(int x){return x&(-x);}
    int main()
    {
    ios::sync_with_stdio(false);
     int a,b;
     while(cin>>a>>b)
     {
         if(!a&&!b)
            break;
         //if(a<b)
            //swap(a,b);
            double k=(1+sqrt(5.0))/2.0;
         int temp=(b-a)*k;
         if(temp==a)
            cout<<0<<endl;
         else
         {
             cout<<1<<endl;
             if(temp<a)
                cout<<temp<<" "<<b-(a-temp)<<endl;
             fro(i,0,b+1)
             {
                 int m=b-i;
                 if(a<m)
                 {if((int)(k*(m-a))==a)
                    cout<<a<<" "<<m<<endl;}
                 else if(a>m)
                     if((int)(k*(a-m))==m)
                    cout<<m<<" "<<a<<endl;
             }
         }
     }
    return 0;
    }







