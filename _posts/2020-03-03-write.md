---
layout: post
title: POJ专题之动态规划背包
date: 2020-03-03
categories: blog
tags: [动态规划]
description: 文章金句。
---

### 背包问题
动态规划的背包问题十分经典。但对于背包的实际转移过程及状态方程的得来还需要深入理解一下。背包问题的数组如：dp[i][j]，后面的j一般就是状态，比如装背包时的体积0-v，前面i就是你要装的东西。一般就是这样，纯粹的背包板子题没什么好说的，主要是变形，变一点点没理解就可能看不出来是01背包，所以多做题是很有必要的。多总结叭！

### Balance POJ - 1837 背包问题
#### 题目大意
有一个天平，天平左右两边各有若干个钩子，总共有C个钩子，有G个钩码，求将钩码全部挂到钩子上使天平平衡的方法的总数。
其中可以把天枰看做一个以x轴0点作为平衡点的横轴。
要求把所有的砝码都放在上面。

#### 思路
刚开始真的无法往背包上面去联想，只到数组为dp[i][j]，却无法定义状态。没有深刻理解背包状态的确立过程。<br>

正解是：确定状态dp[i][j]为当挂前i个砝码时，平衡状态为j的次数。<br>

怎样定义状态？<br>

极端情况下全部砝码放在一侧为：20 * 25 * 15=7500，当然为正负7500，当在数组中没有负数下标（可以定义但值不会改变）。所以延长2倍数组，所以状态确立为0到15000，中间7500为平衡状态。<br>

初始化dp[0][7500]为1，因为不挂砝码时也为平横，其余都为0。

状态转移方程为：**dp[i][j+weight[i] * hook[k]]+=dp[i-1][j]**。外层循环为砝码的数量，第二层为0到15000的状态遍历，不能为7500到15000，这样会导致漏解。

小细节：我发现二维数组的第二个数组可以为负数或越界，结果为0，可以改变。但第一个数组不能越界或为负。还有就是以后动态规划的数组下标尽量从1开始！！！

```
int dp[30][15100];//挂前i个砝码，状态（平衡）为j时的个数
int hook[30];
int weight[30];
int main()
{
    ios::sync_with_stdio(0);
    int n,m;
    cin>>n>>m;
    fro(i,1,n+1){
        cin>>hook[i];
    }
    //cout<<dp[1][20000]<<endl;
    fro(j,1,m+1)
     cin>>weight[j];
     dp[0][7500]=1;//定义7500为平衡
     fro(i,1,m+1){
        fro(j,0,15001){
            if(dp[i-1][j])
            fro(k,1,n+1){
                dp[i][j+weight[i]*hook[k]]+=dp[i-1][j];
                //cout<<weight[i]*hook[k]<<" j="<<j<<endl;
            }
        }
     }
    cout<<dp[m][7500]<<endl;
    return 0;
}
```










