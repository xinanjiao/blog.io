---
layout: post
title: 线段树
date: 2019-8-10
categories: blog
tags: [算法,训练,数据结构]
description: 语言
---
参考博客：<https://www.cnblogs.com/TheRoadToTheGold/p/6254255.html><br/>
         <https://blog.csdn.net/zearot/article/details/48299459><br/>

## 引例
<p style="color: rgb(176,196,222);">A.给出n个数，n<=100，和m个询问，每次询问区间[l，r]的和，并输出。</p>

一种回答：这也太简单了，O（n）枚举搜索就行了。

另一种回答：还用得着o(n）枚举，前缀和o(1)就搞定。

那好，我再修改一下题目。

<p style="color: rgb(189,183,107);">B.给出n个数，n<=100，和m个操作，每个操作可能有两种：1、在某个位置加上一个数；2、询问区间[l，r]的和，并输出。

回答：o（n）枚举。</p>

动态修改最起码不能用静态的前缀和做了。

好，我再修改题目：

<p style="color: rgb(255,192,203);">C.给出n个数，n<=1000000，和m个操作，每个操作可能有两种：1、在某个位置加上一个数；2、询问区间[l，r]的和，并输出。</p>

回答：o（n）枚举绝对超时。

再改：

<p style="color: green;">D，给出n个数，n<=1000000，和m个操作，每个操作修改一段连续区间[a,b]的值</p>

回答：从a枚举到b，一个一个改。。。。。。有点儿常识的人都知道超时

那怎么办？这就需要一种强大的数据结构：<p style="color: red;">线段树。</p>

## 原理

线段树的原理，就是，将[1,n]分解成若干特定的子区间(数量不超过4 * n),然后，将每个区间[L,R]都分解为
少量特定的子区间，通过对这些少量子区间的修改或者统计，来实现快速对[L,R]的修改或者统计。<br/>

由此看出，用线段树统计的东西，必须符合区间加法，否则，不可能通过分成的子区间来得到[L,R]的统计结果。<br/>

**符合区间加法的例子：**<br/>
数字之和——总数字之和 = 左区间数字之和 + 右区间数字之和<br/>
最大公因数(GCD)——总GCD = gcd( 左区间GCD , 右区间GCD );<br/>
最大值——总最大值=max(左区间最大值，右区间最大值)<br/>
**不符合区间加法的例子：**<br/>
众数——只知道左右区间的众数，没法求总区间的众数<br/>
01序列的最长连续零——只知道左右区间的最长连续零，没法知道总的最长连续零<br/>

线段树本质上是维护下标为1,2,..,n的n个按顺序排列的数的信息，所以，其实是“点树”，是维护n的点的信息，至于每个点的数据的含义可以有很多，
在对线段操作的线段树中，每个点代表一条线段，在用线段树维护数列信息的时候，每个点代表一个数，但本质上都是每个点代表一个数。以下，在讨论线段树的时候，区间[L,R]指的是下标从L到R的这(R-L+1)个数，而不是指一条连续的线段。只是有时候这些数代表实际上一条线段的统计结果而已。


线段树是将每个区间[L,R]分解成[L,M]和[M+1,R](其中M=(L+R)/2 这里的除法是整数除法，即对结果下取整)直到 L==R 为止。

下图是[1,13]的分解过程
![tree](/img/tree.png)
由上图可得，

1、每个节点的左孩子区间范围为[l，mid]，右孩子为[mid+1,r]

2、对于结点k，左孩子结点为2*k，右孩子为2*k+1，这符合完全二叉树的性质

## 线段树的基本操作
建树，区间修改，区间查询，单点查询，单点修改

### 建树（递归版）
1 定义

    #define maxn 100007  //元素总个数
    #define ls l,m,rt<<1
    #define rs m+1,r,rt<<1|1
    int Sum[maxn<<2],Add[maxn<<2];//Sum求和，Add为懒惰标记 
    int A[maxn],n;//存原数组数据下标[1,n] 

2 建树

    //PushUp函数更新节点信息 ，这里是求和
    void PushUp(int rt){Sum[rt]=Sum[rt<<1]+Sum[rt<<1|1];}
    //Build函数建树 
    void Build(int l,int r,int rt){ //l,r表示当前节点区间，rt表示当前节点编号
	if(l==r) {//若到达叶节点 
		Sum[rt]=A[l];//储存数组值 
		return;
	}
	int m=(l+r)>>1;
	//左右递归 
	Build(l,m,rt<<1);//等于rt*2
	Build(m+1,r,rt<<1|1);//等于rt*2+1
	//更新信息 
	PushUp(rt);
    }

### 单点修改
假设第L位置上的数加上C，即A[L]+=C；

    void Update(int L,int C,int l,int r,int rt){//l,r表示当前节点区间，rt表示当前节点编号
	if(l==r){//到叶节点，修改 
		Sum[rt]+=C;
		return;
	}
	int m=(l+r)>>1;
	//根据条件判断往左子树调用还是往右 
	if(L <= m) Update(L,C,l,m,rt<<1);
	else       Update(L,C,m+1,r,rt<<1|1);
	PushUp(rt);//子节点更新了，所以本节点也需要更新信息 
    } 






