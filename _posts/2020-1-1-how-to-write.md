---
layout: post
title: 初识交互题
date: 2020-1-1
categories: blog
tags: [交互题]
description: 语言
---

### 交互题
  早在上学训练打组队赛的时候就遇见过交互题，它不同于我们平常做的题。平常的题太过于程序化，输进去就出来结果，而交互题却大大不同。比赛的时候我不知道这是交互题，我尊称它为“图灵测试”，发现最近不管小比赛还是icpc都出现这种题，不了解是不可能了。

#### 我对交互题的理解
<p style="color:red">我也在网上看过别人的总结，也很有道理，它是把输入看做输出，输出看做输入。打个比喻，想象一下。把电脑看做一个神秘人，它有个数啥的东西，叫你给出条件（就是你问它），然后它告诉你是否正确（或者某个范围），最后你根据电脑返回的结果推测最终电脑那里的数后者其他。这个有点像诸葛亮猜士兵心里想的数有木有。当然，电脑返回的数怎么办？？？</p>
<p style="color: red">不管输出的数还是输入的数，都在一个程序实现。即输出的是你向电脑询问的，输入的是电脑回复你的。所以这种题说灵活也不灵活。简单点就是找规律，构造。那难一点就是依据输入二分，三分之类的，这就是要多做题总结了。</p>
![交互](/img/交互.jpg)

### A. Bear and Prime 100 构造
题意：在[2,100]中找到一个隐藏数字，让你判断这个数是质数还是合数，你最多只能查二十次。


题解：打一个[2,50]的素数表，然后加上素数的平方的情况，最多只有19个数。一个一个遍历，能被大于等与两个数整除的就是合数。注意如果用到了printf或scanf 的话需要加上fflush(stdout)这个操作。这个题目上也说了。为什么打2到50的素数表呢，因为所有合数全都由2到50之间的两个数相乘，然而每个合数必有一个质数，如果有，那这个数也必是质数！
列如 86  中因子 1,2,43,86. 每一个100以内的合数包含 质数*另一个质数 这对因子。特例 4,9,25,49 这些数是 质数*这个质数。

    const int p[21]={0,2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,4,9,16,25,49};
    char s[10];
    int main()
    {
    ios::sync_with_stdio(0);
    int sum=0;
    fro(i,1,21)
    {
    cout<<p[i]<<endl;
    fflush(stdout);
    cin>>s;
    if(s[0]=='y')
        sum++;
    }
    if(sum<=1)
        cout<<"prime"<<endl;
    else
        cout<<"composite"<<endl;
    return 0;
    }


### D - Strange Device 构造
题目大意：有一个长度为n的隐藏数组a，其中元素两两不同。你有一台机器可以最多询问n次，每次可以向这个机器输入k个数，这些数是下标（范围1到n）。而机器会返回这些数中第m大的数的值，以及他的下标。已知k，求m。

<p style="color: red">题解：其实解法在样例就有体现（后悔当时没有研究样例）。我们只需对前k+1个数查询k+1次，这样只会得到两个元素的值，一个是第m大的数，一个是第m+1大的数。第m大的数会出现（k + 1 - m）次， 第m + 1大的数会出现 m 次。所以我们只需要统计较大值出现的次数就是答案m了。

那为什么第m大的数会出现（k + 1 - m）次， 第m + 1大的数会出现 m 次？

答：当我们对前k+1个数询问k+1次时，实际上就是依次从k+1个数中去掉一个数进行查询。如果去掉的是前1 ~ m中的某一个数，那询问所得到的值则只会是第m + 1大的数。剩下的去掉m+1 ~ k + 1中的数，询问所得到的值必将会是第m大的数。,构造得很巧妙，我推了很久却没啥子结果.....
</p>

    #include<bits/stdc++>
    int main()
    {
    ios::sync_with_stdio(0);
    map<int,int> mp;
    int n,k;
    cin>>n>>k;
    for(int i=1;i<=k+1;i++)
    {
        cout<<"?";
        fflush(stdout);
        for(int j=1;j<=k+1;j++)
            if(j!=i)
            {
                cout<<" "<<j;
                fflush(stdout);
            }
            cout<<endl;
        int x,y;
        cin>>x>>y;
        mp[y]++;
    }
    cout<<"! "<<(*mp.rbegin()).se<<endl;
    return 0;
    }



